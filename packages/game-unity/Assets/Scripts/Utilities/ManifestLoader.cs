using System;
using System.Collections.Generic;
using UnityEngine;

namespace NeoTokyo.Utilities
{
    /// <summary>
    /// Loads and parses JSON manifests generated by TypeScript world-gen.
    /// This is the bridge between TypeScript dev tools and Unity runtime.
    /// </summary>
    public static class ManifestLoader
    {
        /// <summary>
        /// Load a territory manifest from the _Generated folder.
        /// </summary>
        public static TerritoryManifest LoadTerritory(string seed, string territoryId)
        {
            var path = $"_Generated/Manifests/{seed}/{territoryId}";
            var textAsset = Resources.Load<TextAsset>(path);

            if (textAsset == null)
            {
                Debug.LogWarning($"Territory manifest not found: {path}");
                return null;
            }

            return JsonUtility.FromJson<TerritoryManifest>(textAsset.text);
        }

        /// <summary>
        /// Load the world manifest containing all territory references.
        /// </summary>
        public static WorldManifest LoadWorld(string seed)
        {
            var path = $"_Generated/Manifests/{seed}/world";
            var textAsset = Resources.Load<TextAsset>(path);

            if (textAsset == null)
            {
                Debug.LogWarning($"World manifest not found: {path}");
                return null;
            }

            return JsonUtility.FromJson<WorldManifest>(textAsset.text);
        }
    }

    /// <summary>
    /// World manifest schema - matches TypeScript world-gen output.
    /// </summary>
    [Serializable]
    public class WorldManifest
    {
        public string version;
        public string seed;
        public TerritoryReference[] territories;
    }

    /// <summary>
    /// Reference to a territory for streaming.
    /// </summary>
    [Serializable]
    public class TerritoryReference
    {
        public string id;
        public string type;
        public string faction;
        public Vector2Int[] bounds;  // [min, max]
    }

    /// <summary>
    /// Full territory definition - matches TypeScript DDL output.
    /// </summary>
    [Serializable]
    public class TerritoryManifest
    {
        public string id;
        public string type;  // academy, market, refuge, factory, ruin, shrine
        public string faction;  // Kurenai, Azure, Neutral, etc.
        public Bounds2D bounds;
        public TileDefinition[] tiles;
        public EntityDefinition[] entities;
        public ConnectionDefinition[] connections;
    }

    [Serializable]
    public class Bounds2D
    {
        public float[] min;  // [x, z]
        public float[] max;  // [x, z]
    }

    /// <summary>
    /// Hex tile definition from procedural generation.
    /// Matches TypeScript: HexTile in world-gen
    /// </summary>
    [Serializable]
    public class TileDefinition
    {
        public HexCoord hex;
        public string type;  // water, platform, rooftop, bridge, dock, debris
        public float elevation;  // Height above water level (4 = waterline)
        public string variant;  // Specific visual variant
        public string material;  // PBR material override
    }

    [Serializable]
    public class HexCoord
    {
        public int q;  // Axial q coordinate
        public int r;  // Axial r coordinate

        /// <summary>
        /// Convert axial to cube coordinates.
        /// </summary>
        public Vector3Int ToCube() => new Vector3Int(q, -q - r, r);

        /// <summary>
        /// Convert to world position.
        /// </summary>
        public Vector3 ToWorldPosition(float hexSize = 1f)
        {
            float x = hexSize * (Mathf.Sqrt(3f) * q + Mathf.Sqrt(3f) / 2f * r);
            float z = hexSize * (3f / 2f * r);
            return new Vector3(x, 0f, z);
        }
    }

    /// <summary>
    /// Entity spawn definition from world-gen.
    /// </summary>
    [Serializable]
    public class EntityDefinition
    {
        public string type;  // shelter, bridge, dock, boat, npc, enemy, etc.
        public float[] position;  // [x, y, z]
        public float rotation;  // Y-axis rotation in degrees
        public string variant;  // Specific prefab variant
        public Dictionary<string, object> properties;  // Type-specific properties
    }

    /// <summary>
    /// Connection between territories (bridges, boat routes).
    /// </summary>
    [Serializable]
    public class ConnectionDefinition
    {
        public string type;  // bridge, boat_route, cable
        public string targetTerritory;
        public float[] startPosition;
        public float[] endPosition;
        public string variant;
    }
}
