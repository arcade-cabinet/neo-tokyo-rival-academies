using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;
using NeoTokyo.Data;

namespace NeoTokyo.Utilities
{
    /// <summary>
    /// Loads and parses JSON manifests generated by TypeScript world-gen.
    /// This is the bridge between TypeScript dev tools and Unity runtime.
    ///
    /// Supports multiple loading strategies:
    /// - Resources (built-in, synchronous)
    /// - StreamingAssets (file-based, async)
    /// - Addressables (optional, async with caching)
    /// </summary>
    public static class ManifestLoader
    {
        #region Configuration

        /// <summary>
        /// Loading strategy enumeration.
        /// </summary>
        public enum LoadStrategy
        {
            Resources,
            StreamingAssets,
            Addressables
        }

        /// <summary>
        /// Current active loading strategy.
        /// </summary>
        public static LoadStrategy ActiveStrategy { get; set; } = LoadStrategy.StreamingAssets;

        /// <summary>
        /// Base path for manifest files (relative to strategy root).
        /// </summary>
        public static string ManifestBasePath { get; set; } = "_Generated/Manifests";

        /// <summary>
        /// Enable caching of loaded manifests.
        /// </summary>
        public static bool EnableCaching { get; set; } = true;

        /// <summary>
        /// Log verbose loading information.
        /// </summary>
        public static bool VerboseLogging { get; set; } = false;

        #endregion

        #region Cache

        private static readonly Dictionary<string, WorldManifest> _worldCache
            = new Dictionary<string, WorldManifest>();

        private static readonly Dictionary<string, TerritoryManifest> _territoryCache
            = new Dictionary<string, TerritoryManifest>();

        /// <summary>
        /// Clear all cached manifests.
        /// </summary>
        public static void ClearCache()
        {
            _worldCache.Clear();
            _territoryCache.Clear();
            Log("Manifest cache cleared");
        }

        /// <summary>
        /// Get cache statistics.
        /// </summary>
        public static (int worlds, int territories) GetCacheStats()
        {
            return (_worldCache.Count, _territoryCache.Count);
        }

        #endregion

        #region Synchronous Loading (Resources)

        /// <summary>
        /// Load a world manifest synchronously from Resources.
        /// </summary>
        public static ManifestLoadResult<WorldManifest> LoadWorld(string seed)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            // Check cache
            string cacheKey = $"world_{seed}";
            if (EnableCaching && _worldCache.TryGetValue(cacheKey, out var cached))
            {
                Log($"World manifest cache hit: {seed}");
                return ManifestLoadResult<WorldManifest>.Succeeded(cached, 0f);
            }

            string path = GetResourcePath(seed, "world");
            var textAsset = Resources.Load<TextAsset>(path);

            if (textAsset == null)
            {
                return ManifestLoadResult<WorldManifest>.Failed($"World manifest not found: {path}");
            }

            try
            {
                var manifest = JsonUtility.FromJson<WorldManifest>(textAsset.text);

                if (!ManifestVersion.IsCompatible(manifest.version))
                {
                    LogWarning($"World manifest version mismatch: {manifest.version} (expected {ManifestVersion.CURRENT})");
                }

                if (EnableCaching)
                {
                    _worldCache[cacheKey] = manifest;
                }

                stopwatch.Stop();
                Log($"Loaded world manifest: {seed} in {stopwatch.ElapsedMilliseconds}ms");

                return ManifestLoadResult<WorldManifest>.Succeeded(manifest, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                return ManifestLoadResult<WorldManifest>.Failed($"Failed to parse world manifest: {ex.Message}");
            }
        }

        /// <summary>
        /// Load a territory manifest synchronously from Resources.
        /// </summary>
        public static ManifestLoadResult<TerritoryManifest> LoadTerritory(string seed, string territoryId)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            // Check cache
            string cacheKey = $"territory_{seed}_{territoryId}";
            if (EnableCaching && _territoryCache.TryGetValue(cacheKey, out var cached))
            {
                Log($"Territory manifest cache hit: {territoryId}");
                return ManifestLoadResult<TerritoryManifest>.Succeeded(cached, 0f);
            }

            string path = GetResourcePath(seed, territoryId);
            var textAsset = Resources.Load<TextAsset>(path);

            if (textAsset == null)
            {
                return ManifestLoadResult<TerritoryManifest>.Failed($"Territory manifest not found: {path}");
            }

            try
            {
                var manifest = JsonUtility.FromJson<TerritoryManifest>(textAsset.text);

                if (!ManifestVersion.IsCompatible(manifest.version))
                {
                    LogWarning($"Territory manifest version mismatch: {manifest.version} (expected {ManifestVersion.CURRENT})");
                }

                if (EnableCaching)
                {
                    _territoryCache[cacheKey] = manifest;
                }

                stopwatch.Stop();
                Log($"Loaded territory manifest: {territoryId} in {stopwatch.ElapsedMilliseconds}ms");

                return ManifestLoadResult<TerritoryManifest>.Succeeded(manifest, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                return ManifestLoadResult<TerritoryManifest>.Failed($"Failed to parse territory manifest: {ex.Message}");
            }
        }

        #endregion

        #region Asynchronous Loading (StreamingAssets)

        /// <summary>
        /// Load a world manifest asynchronously from StreamingAssets.
        /// </summary>
        public static async Task<ManifestLoadResult<WorldManifest>> LoadWorldAsync(string seed)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            // Check cache
            string cacheKey = $"world_{seed}";
            if (EnableCaching && _worldCache.TryGetValue(cacheKey, out var cached))
            {
                Log($"World manifest cache hit: {seed}");
                return ManifestLoadResult<WorldManifest>.Succeeded(cached, 0f);
            }

            string path = GetStreamingAssetsPath(seed, "world");
            string json = await LoadJsonFromPathAsync(path);

            if (json == null)
            {
                return ManifestLoadResult<WorldManifest>.Failed($"World manifest not found: {path}");
            }

            try
            {
                var manifest = JsonUtility.FromJson<WorldManifest>(json);

                if (!ManifestVersion.IsCompatible(manifest.version))
                {
                    LogWarning($"World manifest version mismatch: {manifest.version} (expected {ManifestVersion.CURRENT})");
                }

                if (EnableCaching)
                {
                    _worldCache[cacheKey] = manifest;
                }

                stopwatch.Stop();
                Log($"Loaded world manifest async: {seed} in {stopwatch.ElapsedMilliseconds}ms");

                return ManifestLoadResult<WorldManifest>.Succeeded(manifest, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                return ManifestLoadResult<WorldManifest>.Failed($"Failed to parse world manifest: {ex.Message}");
            }
        }

        /// <summary>
        /// Load a territory manifest asynchronously from StreamingAssets.
        /// </summary>
        public static async Task<ManifestLoadResult<TerritoryManifest>> LoadTerritoryAsync(
            string seed,
            string territoryId)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            // Check cache
            string cacheKey = $"territory_{seed}_{territoryId}";
            if (EnableCaching && _territoryCache.TryGetValue(cacheKey, out var cached))
            {
                Log($"Territory manifest cache hit: {territoryId}");
                return ManifestLoadResult<TerritoryManifest>.Succeeded(cached, 0f);
            }

            string path = GetStreamingAssetsPath(seed, territoryId);
            string json = await LoadJsonFromPathAsync(path);

            if (json == null)
            {
                return ManifestLoadResult<TerritoryManifest>.Failed($"Territory manifest not found: {path}");
            }

            try
            {
                var manifest = JsonUtility.FromJson<TerritoryManifest>(json);

                if (!ManifestVersion.IsCompatible(manifest.version))
                {
                    LogWarning($"Territory manifest version mismatch: {manifest.version} (expected {ManifestVersion.CURRENT})");
                }

                if (EnableCaching)
                {
                    _territoryCache[cacheKey] = manifest;
                }

                stopwatch.Stop();
                Log($"Loaded territory manifest async: {territoryId} in {stopwatch.ElapsedMilliseconds}ms");

                return ManifestLoadResult<TerritoryManifest>.Succeeded(manifest, stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                return ManifestLoadResult<TerritoryManifest>.Failed($"Failed to parse territory manifest: {ex.Message}");
            }
        }

        /// <summary>
        /// Load multiple territories in parallel.
        /// </summary>
        public static async Task<BatchLoadResult> LoadTerritoriesBatchAsync(
            string seed,
            IEnumerable<string> territoryIds)
        {
            var result = new BatchLoadResult();
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var tasks = new List<Task<ManifestLoadResult<TerritoryManifest>>>();

            foreach (var id in territoryIds)
            {
                result.TotalRequested++;
                tasks.Add(LoadTerritoryAsync(seed, id));
            }

            var results = await Task.WhenAll(tasks);
            var idList = new List<string>(territoryIds);

            for (int i = 0; i < results.Length; i++)
            {
                var loadResult = results[i];
                var territoryId = idList[i];

                if (loadResult.Success)
                {
                    result.Succeeded++;
                    result.LoadedTerritories[territoryId] = loadResult.Data;
                }
                else
                {
                    result.Failed++;
                    result.Errors.Add($"{territoryId}: {loadResult.Error}");
                }
            }

            stopwatch.Stop();
            result.TotalLoadTime = stopwatch.ElapsedMilliseconds;

            Log($"Batch loaded {result.Succeeded}/{result.TotalRequested} territories in {result.TotalLoadTime}ms");

            return result;
        }

        #endregion

        #region Coroutine Loading (Unity-friendly async)

        /// <summary>
        /// Load world manifest as coroutine (for MonoBehaviour usage).
        /// </summary>
        public static IEnumerator LoadWorldCoroutine(
            string seed,
            Action<ManifestLoadResult<WorldManifest>> callback)
        {
            var task = LoadWorldAsync(seed);

            while (!task.IsCompleted)
            {
                yield return null;
            }

            callback?.Invoke(task.Result);
        }

        /// <summary>
        /// Load territory manifest as coroutine (for MonoBehaviour usage).
        /// </summary>
        public static IEnumerator LoadTerritoryCoroutine(
            string seed,
            string territoryId,
            Action<ManifestLoadResult<TerritoryManifest>> callback)
        {
            var task = LoadTerritoryAsync(seed, territoryId);

            while (!task.IsCompleted)
            {
                yield return null;
            }

            callback?.Invoke(task.Result);
        }

        /// <summary>
        /// Load all territories from a world manifest.
        /// </summary>
        public static IEnumerator LoadAllTerritoriesCoroutine(
            string seed,
            Action<TerritoryManifest> onTerritoryLoaded,
            Action<BatchLoadResult> onComplete)
        {
            var worldResult = LoadWorld(seed);
            if (!worldResult.Success)
            {
                onComplete?.Invoke(new BatchLoadResult
                {
                    Failed = 1,
                    Errors = new List<string> { worldResult.Error }
                });
                yield break;
            }

            var result = new BatchLoadResult();
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            foreach (var territoryRef in worldResult.Data.territories)
            {
                result.TotalRequested++;

                var task = LoadTerritoryAsync(seed, territoryRef.id);

                while (!task.IsCompleted)
                {
                    yield return null;
                }

                if (task.Result.Success)
                {
                    result.Succeeded++;
                    result.LoadedTerritories[territoryRef.id] = task.Result.Data;
                    onTerritoryLoaded?.Invoke(task.Result.Data);
                }
                else
                {
                    result.Failed++;
                    result.Errors.Add($"{territoryRef.id}: {task.Result.Error}");
                }
            }

            stopwatch.Stop();
            result.TotalLoadTime = stopwatch.ElapsedMilliseconds;

            onComplete?.Invoke(result);
        }

        #endregion

        #region Path Utilities

        private static string GetResourcePath(string seed, string manifestName)
        {
            return $"{ManifestBasePath}/{seed}/{manifestName}";
        }

        private static string GetStreamingAssetsPath(string seed, string manifestName)
        {
            string basePath = Application.streamingAssetsPath;
            return Path.Combine(basePath, ManifestBasePath, seed, $"{manifestName}.json");
        }

        private static async Task<string> LoadJsonFromPathAsync(string path)
        {
            // On Android, StreamingAssets requires UnityWebRequest
            if (path.Contains("://") || path.Contains(":///"))
            {
                return await LoadJsonFromWebRequestAsync(path);
            }

            // On other platforms, we can use file system directly
            if (File.Exists(path))
            {
                try
                {
                    return await File.ReadAllTextAsync(path);
                }
                catch (Exception ex)
                {
                    LogError($"Failed to read file: {path} - {ex.Message}");
                    return null;
                }
            }

            // Fallback to UnityWebRequest for platform compatibility
            return await LoadJsonFromWebRequestAsync("file://" + path);
        }

        private static async Task<string> LoadJsonFromWebRequestAsync(string uri)
        {
            using var request = UnityWebRequest.Get(uri);
            var operation = request.SendWebRequest();

            while (!operation.isDone)
            {
                await Task.Yield();
            }

            if (request.result != UnityWebRequest.Result.Success)
            {
                Log($"Web request failed: {uri} - {request.error}");
                return null;
            }

            return request.downloadHandler.text;
        }

        #endregion

        #region Validation

        /// <summary>
        /// Validate a world manifest for completeness.
        /// </summary>
        public static List<string> ValidateWorldManifest(WorldManifest manifest)
        {
            var errors = new List<string>();

            if (manifest == null)
            {
                errors.Add("Manifest is null");
                return errors;
            }

            if (string.IsNullOrEmpty(manifest.version))
            {
                errors.Add("Missing version field");
            }
            else if (!ManifestVersion.IsCompatible(manifest.version))
            {
                errors.Add($"Incompatible version: {manifest.version}");
            }

            if (string.IsNullOrEmpty(manifest.seed))
            {
                errors.Add("Missing seed field");
            }

            if (manifest.territories == null || manifest.territories.Length == 0)
            {
                errors.Add("No territories defined");
            }
            else
            {
                var seenIds = new HashSet<string>();
                foreach (var territory in manifest.territories)
                {
                    if (string.IsNullOrEmpty(territory.id))
                    {
                        errors.Add("Territory with missing id");
                    }
                    else if (!seenIds.Add(territory.id))
                    {
                        errors.Add($"Duplicate territory id: {territory.id}");
                    }
                }
            }

            return errors;
        }

        /// <summary>
        /// Validate a territory manifest for completeness.
        /// </summary>
        public static List<string> ValidateTerritoryManifest(TerritoryManifest manifest)
        {
            var errors = new List<string>();

            if (manifest == null)
            {
                errors.Add("Manifest is null");
                return errors;
            }

            if (string.IsNullOrEmpty(manifest.version))
            {
                errors.Add("Missing version field");
            }

            if (string.IsNullOrEmpty(manifest.id))
            {
                errors.Add("Missing id field");
            }

            if (string.IsNullOrEmpty(manifest.type))
            {
                errors.Add("Missing type field");
            }

            if (manifest.bounds == null)
            {
                errors.Add("Missing bounds definition");
            }

            if (manifest.tiles == null)
            {
                errors.Add("Missing tiles array");
            }
            else
            {
                var seenCoords = new HashSet<string>();
                foreach (var tile in manifest.tiles)
                {
                    if (tile.hex == null)
                    {
                        errors.Add("Tile with missing hex coordinate");
                        continue;
                    }

                    string coordKey = $"{tile.hex.q},{tile.hex.r}";
                    if (!seenCoords.Add(coordKey))
                    {
                        errors.Add($"Duplicate tile coordinate: {coordKey}");
                    }
                }
            }

            // Validate entities
            if (manifest.entities != null)
            {
                var seenEntityIds = new HashSet<string>();
                foreach (var entity in manifest.entities)
                {
                    if (!string.IsNullOrEmpty(entity.id) && !seenEntityIds.Add(entity.id))
                    {
                        errors.Add($"Duplicate entity id: {entity.id}");
                    }

                    if (entity.position == null || entity.position.Length < 3)
                    {
                        errors.Add($"Entity {entity.id ?? "unknown"} has invalid position");
                    }
                }
            }

            return errors;
        }

        #endregion

        #region Logging

        private static void Log(string message)
        {
            if (VerboseLogging)
            {
                Debug.Log($"[ManifestLoader] {message}");
            }
        }

        private static void LogWarning(string message)
        {
            Debug.LogWarning($"[ManifestLoader] {message}");
        }

        private static void LogError(string message)
        {
            Debug.LogError($"[ManifestLoader] {message}");
        }

        #endregion

        #region Backwards Compatibility

        /// <summary>
        /// Legacy method - loads territory synchronously.
        /// Use LoadTerritory or LoadTerritoryAsync instead.
        /// </summary>
        [Obsolete("Use LoadTerritory() which returns ManifestLoadResult")]
        public static LegacyTerritoryManifest LoadTerritoryLegacy(string seed, string territoryId)
        {
            var result = LoadTerritory(seed, territoryId);
            if (!result.Success) return null;

            // Convert to legacy format
            return new LegacyTerritoryManifest
            {
                id = result.Data.id,
                type = result.Data.type,
                faction = result.Data.faction,
                bounds = ConvertBounds(result.Data.bounds),
                tiles = ConvertTiles(result.Data.tiles),
                entities = ConvertEntities(result.Data.entities),
                connections = ConvertConnections(result.Data.connections)
            };
        }

        private static LegacyBounds2D ConvertBounds(BoundsDefinition bounds)
        {
            return new LegacyBounds2D
            {
                min = bounds?.min,
                max = bounds?.max
            };
        }

        private static LegacyTileDefinition[] ConvertTiles(TileDefinition[] tiles)
        {
            if (tiles == null) return new LegacyTileDefinition[0];

            var result = new LegacyTileDefinition[tiles.Length];
            for (int i = 0; i < tiles.Length; i++)
            {
                result[i] = new LegacyTileDefinition
                {
                    hex = new LegacyHexCoord { q = tiles[i].hex.q, r = tiles[i].hex.r },
                    type = tiles[i].type,
                    elevation = tiles[i].elevation,
                    variant = tiles[i].variant,
                    material = tiles[i].material
                };
            }
            return result;
        }

        private static LegacyEntityDefinition[] ConvertEntities(EntityDefinition[] entities)
        {
            if (entities == null) return new LegacyEntityDefinition[0];

            var result = new LegacyEntityDefinition[entities.Length];
            for (int i = 0; i < entities.Length; i++)
            {
                result[i] = new LegacyEntityDefinition
                {
                    type = entities[i].type,
                    position = entities[i].position,
                    rotation = entities[i].rotation,
                    variant = entities[i].variant
                };
            }
            return result;
        }

        private static LegacyConnectionDefinition[] ConvertConnections(ConnectionDefinition[] connections)
        {
            if (connections == null) return new LegacyConnectionDefinition[0];

            var result = new LegacyConnectionDefinition[connections.Length];
            for (int i = 0; i < connections.Length; i++)
            {
                result[i] = new LegacyConnectionDefinition
                {
                    type = connections[i].type,
                    targetTerritory = connections[i].targetTerritory,
                    startPosition = connections[i].startPosition,
                    endPosition = connections[i].endPosition,
                    variant = connections[i].variant
                };
            }
            return result;
        }

        #endregion
    }

    #region Legacy Schema Types (Backwards Compatibility)

    /// <summary>
    /// Legacy world manifest - for backwards compatibility only.
    /// </summary>
    [Obsolete("Use NeoTokyo.Data.WorldManifest instead")]
    [Serializable]
    public class LegacyWorldManifest
    {
        public string version;
        public string seed;
        public LegacyTerritoryReference[] territories;
    }

    [Obsolete("Use NeoTokyo.Data.TerritoryReference instead")]
    [Serializable]
    public class LegacyTerritoryReference
    {
        public string id;
        public string type;
        public string faction;
        public Vector2Int[] bounds;
    }

    [Obsolete("Use NeoTokyo.Data.TerritoryManifest instead")]
    [Serializable]
    public class LegacyTerritoryManifest
    {
        public string id;
        public string type;
        public string faction;
        public LegacyBounds2D bounds;
        public LegacyTileDefinition[] tiles;
        public LegacyEntityDefinition[] entities;
        public LegacyConnectionDefinition[] connections;
    }

    [Obsolete("Use NeoTokyo.Data.BoundsDefinition instead")]
    [Serializable]
    public class LegacyBounds2D
    {
        public float[] min;
        public float[] max;
    }

    [Obsolete("Use NeoTokyo.Data.TileDefinition instead")]
    [Serializable]
    public class LegacyTileDefinition
    {
        public LegacyHexCoord hex;
        public string type;
        public float elevation;
        public string variant;
        public string material;
    }

    [Obsolete("Use NeoTokyo.Data.HexCoordDefinition instead")]
    [Serializable]
    public class LegacyHexCoord
    {
        public int q;
        public int r;

        public Vector3Int ToCube() => new Vector3Int(q, -q - r, r);

        public Vector3 ToWorldPosition(float hexSize = 1f)
        {
            float x = hexSize * (Mathf.Sqrt(3f) * q + Mathf.Sqrt(3f) / 2f * r);
            float z = hexSize * (3f / 2f * r);
            return new Vector3(x, 0f, z);
        }
    }

    [Obsolete("Use NeoTokyo.Data.EntityDefinition instead")]
    [Serializable]
    public class LegacyEntityDefinition
    {
        public string type;
        public float[] position;
        public float rotation;
        public string variant;
        public Dictionary<string, object> properties;
    }

    [Obsolete("Use NeoTokyo.Data.ConnectionDefinition instead")]
    [Serializable]
    public class LegacyConnectionDefinition
    {
        public string type;
        public string targetTerritory;
        public float[] startPosition;
        public float[] endPosition;
        public string variant;
    }

    #endregion
}
